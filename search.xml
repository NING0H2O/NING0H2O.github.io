<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>责任链模式在字段验证场景中的使用</title>
      <link href="/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/"/>
      <url>/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式在字段验证场景中的使用"><a href="#责任链模式在字段验证场景中的使用" class="headerlink" title="责任链模式在字段验证场景中的使用"></a>责任链模式在字段验证场景中的使用</h1><p>最近在搬砖过程中有一个保存大表单的需求（搬砖CRUD常态），在保存这个大表单之前有一系列的检验（字段校验使用了JSR303），表单名不能和已有的重名、表单数量、同时还有一些字段是互斥不能同时选择的等等一些情况。</p><p>当时做这个的时候直接if else一把梭了，不过写到后面发现满屏的if else怎么看怎么别扭。</p><pre class=" language-Java"><code class="language-Java">public boolean validate(Query query) &#123;    if (表单名验证)&#123;    &#125; else if (表单数量验证) &#123;    &#125; else if (时间校验) &#123;    &#125;    ...&#125;</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote><p>顾名思义，责任链模式（Chain of Responsibility Pattern）<strong>为请求创建了一个接收者对象的链</strong>。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，<strong>通常每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会<strong>把相同的请求传给下一个接收者</strong>，依此类推。 </p><p>​                                                                                                                                        来源：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p></blockquote><p>简而言之，责任链模式就是一个对象经过一系列链接成链条的处理对象从而进行一系列处理。</p><p>从上面的定义可以看出责任链模式非常适合用来对同一个对象进行一系列处理的场合，如SpringMVC的拦截器使用场景，对Request进行拦截处理。对表单对象进行检验的场景也非常适合使用责任链模式。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在校验场景中，待处理对象就是表单对象，一系列的进行处理的对象则是一系列的校验器。因此首先需要一个校验器的接口，如下：</p><pre class=" language-Java"><code class="language-Java">public interface Validator &#123;    ValidateResult validate(ReportQuery reportQuery);&#125;</code></pre><p>对表单进行校验的校验器通过实现Validator接口即可：</p><pre class=" language-Java"><code class="language-Java">// 表单名验证public class ReportNameValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单名校验逻辑    &#125;&#125;// 表单数量验证public class ReportSizeValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单数量校验逻辑    &#125;&#125;</code></pre><p>链条上的进行处理的对象已经有了，现在需要一个可以把这些处理对象链接起来的并且可以按照链条顺序一一执行校验的对象：</p><pre class=" language-Java"><code class="language-Java">public class ReportValidator &#123;    // 检验器集合    private List<Validator> validators = new ArrayList<>();    // 添加校验器并链接成链条    public ReportValidator addValidator(Validator validator) &#123;        validators.add(validator);        return this;    &#125;    // 按照链条顺序执行校验    public ValidateResult validate(ReportQuery reportQuery) &#123;        ValidateResult validateResult = null;        for (Validator validator : validators) &#123;            validateResult = validator.validate(reportQuery);            if (!validateResult.isSuccess()) &#123;                return validateResult;            &#125;        &#125;        return validateResult;    &#125;&#125;</code></pre><p>然后，使用起来是这样子的：</p><pre class=" language-Java"><code class="language-Java">    @PostMapping("/urlpath")    public JsonCommonResponse fun(@RequestBody ReportQuery reportQuery) &#123;        // 校验        ReportValidator reportValidator = new ReportValidator().addValidator(new ReportNameValidator())                .addValidator(new ReportSizeValidator());        ValidateResult validateResult = reportValidator.validate(reportQuery);        if (!validateResult.isSuccess()) &#123;            return JsonCommonResponse.failRes(validateResult.getResultCode());        &#125;        // 业务逻辑    &#125;</code></pre><p>这样子使用起来十分方便，而且可读性也很好，扩展也十分方便，如果有新的校验逻辑，新建一个检验器类，添加到链条中即可。</p><p><strong>注：</strong>一些校验器的检验逻辑可能会依赖它前面的校验结果，可能会导致NPE（检验器的添加顺序也请务必仔细考虑）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式非常适合用于<strong>对一个对象进行一系列的处理</strong>，如过滤（过滤器），拦截（拦截器），检验（检验器）。</p><p>表单校验使用责任链模式和JSR303配合校验十分方便，而且可读性可维护性扩展性都挺不错。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ning0h2o的第一篇Blog</title>
      <link href="/ning0h2o-de-di-yi-pian-blog/"/>
      <url>/ning0h2o-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Ning0h2o的第一篇Blog"><a href="#Ning0h2o的第一篇Blog" class="headerlink" title="Ning0h2o的第一篇Blog"></a>Ning0h2o的第一篇Blog</h1><p>Hi，这里是Ning0h2o的blog，一枚刚进入职场的Java搬砖工程师~~</p><h2 id="一段简短的自我介绍"><a href="#一段简短的自我介绍" class="headerlink" title="一段简短的自我介绍"></a>一段简短的自我介绍</h2><p>ning0h2o（这个昵称可以转化成我的姓名哦，化学表达式+谐音这样子？），2020届大学毕业生，现在在狗东搬砖，唯一的兴趣就是打游戏打游戏打游戏了</p><h2 id="这个博客有什么内容？"><a href="#这个博客有什么内容？" class="headerlink" title="这个博客有什么内容？"></a>这个博客有什么内容？</h2><p>Java开发方面的技术记录文，类似个人学习笔记和开发笔记，大多会是一些知识点的罗列和简单说明，不会太深层次的去研讨技术（大佬请绕道）。</p><h2 id="写博客的理由"><a href="#写博客的理由" class="headerlink" title="写博客的理由"></a>写博客的理由</h2><ol><li>我记了很多笔记，有道云笔记现在大概有300来篇笔记了吧，但是都是一些零零散散的知识点，分类也乱七八糟的。而且在我记完笔记之后很少去看，到现在有些已经遗忘的差不多了。通过写博客的方式review和重新编排一下，同时也是把这些知识点构建成知识体系的有效途径</li><li>到现在已经入职一个多月了，对自己所在岗位也有一定的了解，我会在接下来一段相对长的时间从事搬砖的活（谁叫自己菜呢）。不过还好，开发用的那套技术栈和我掌握的重合性很高，很多知识点也是在我的笔记里有所记录。因此，写博客复习也有助于搬砖（误）</li><li>俗话说的好，“靠山山倒”。在开发这条路上总不能就靠我那百来多篇笔记了吧？那样子的话一辈子都是搬砖工了（笑）。我会去学习一些新技术，并且通过写博客的方式记录知识点和我的一些理解</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>能看到这儿的话，说明你是真的闲（笑）。从我上面写的内容你也大概看的出我文笔菜的一批，说来也惭愧，我高考语文差点不及格（苦笑）。在以后的博客写作中我会尽量保证语句通顺，在技术点说明这方面也会尽量保持正确性，个人理（忽）解（悠）处也会给出相应的标记（哈哈，不要被我忽悠了）</p><p>最后，十分感谢你能来到我的博客。如果你有什么建议或者想法对我说，可以在下方评论区留言，也可以加我企鹅号~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
