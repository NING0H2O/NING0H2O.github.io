<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>位移在枚举中的应用</title>
      <link href="/wei-yi-zai-mei-ju-zhong-de-ying-yong/"/>
      <url>/wei-yi-zai-mei-ju-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="位移在枚举中的应用"><a href="#位移在枚举中的应用" class="headerlink" title="位移在枚举中的应用"></a>位移在枚举中的应用</h1><p>最近在公司代码中发现一个枚举类中使用了位移来表示枚举值，不是很能理解为何这样设置，遂去问了度娘和老同事。大概意思就是存在多个枚举组合使用的情况下使用位移能很方便的分辨出是哪些枚举。</p><pre class=" language-Java"><code class="language-Java">public enum BusinessType &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);&#125;</code></pre><p>如上是一个产品线枚举，如果想判断某个产品是否同时属于产品线A和产品线B，可以这样子来判断：</p><pre class=" language-Java"><code class="language-Java">    Integer type = BusinessType.A.getCode() + BusinessType.B.getCode();    if ((obj.getBusinessType() & type) == type) &#123;    &#125;</code></pre><h2 id="举一反三，在检验场景中的使用"><a href="#举一反三，在检验场景中的使用" class="headerlink" title="举一反三，在检验场景中的使用"></a>举一反三，在检验场景中的使用</h2><p>接上次的检验场景，表单对象中的用户可选的标签中有几个有冲突不能同时选择，在保存表单对象必须对这些情况进行检验。</p><h3 id="1-构建枚举类"><a href="#1-构建枚举类" class="headerlink" title="1.构建枚举类"></a>1.构建枚举类</h3><p>很幸运，公司代码中已经有用户选择标签的枚举类了，但是没有可供使用的位移枚举值，因此扩展一下，如下：</p><pre class=" language-Java"><code class="language-Java">public enum Label &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);    D("DDD", 1 << 3);&#125;</code></pre><h3 id="2-设计冲突规则-amp-计算校验和"><a href="#2-设计冲突规则-amp-计算校验和" class="headerlink" title="2.设计冲突规则&amp;计算校验和"></a>2.设计冲突规则&amp;计算校验和</h3><p>比如，A和B不能同时选择校验规则，至少选择一个标签，当然也适用比较复杂的校验规则，如必须ABCD之间自由组合，这些规则可以按如下设计：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// AB不能同时选择</span>    Integer ABConflictRule <span class="token operator">=</span> Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 至少选择一个</span>    Integer leastOneCheckedRule <span class="token operator">=</span> ABConflictRule <span class="token operator">+</span> Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> complexCheckRule <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>                            Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>冲突规则设计完毕之后，就需要计算所选择标签的校验和了，</p><pre class=" language-Java"><code class="language-Java">    int checkSum = 0;    for (Label label : query.getLabels()) &#123;        checkSum += Lable.descOf(label.getDesc).getCode();    &#125;</code></pre><h3 id="3-进行校验"><a href="#3-进行校验" class="headerlink" title="3.进行校验"></a>3.进行校验</h3><p>对校验和和冲突规则使用位移运算，然后根据位移运算之后的结果判断是否冲突，如：</p><pre class=" language-Java"><code class="language-Java">    if ((ABConflictRule & checkSum) == ABConflictRule) &#123;        System.out.println("AB冲突了");    &#125;    if ((leastOneCheckedRule & checkSum) == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 也可以这样    if (chcksum == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 至少选择一个标签 && 不能选择一个标签 = ABCD之间自由组合    if ((leastOneCheckedRule & checkSum) == 0 && complexCheckRule.contains(checkSum)) &#123;        System.out.println("标签之间没有自由组合");    &#125;</code></pre><p>最后一个校验稍微有点复杂，需要进行一下换算。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位移运算在工作中很少使用到，以前只知道位移效率高，可以用来替代 乘法 和 除法。对位移运算的理解和应用也仅仅只限于熟悉运算规则并进行计算而已，很难想到上面这种通过位移来进行筛选。其实关于上面这些操作在离散数学中都有介绍，只能怪自己当初摸鱼了（囧）。。。</p><p>现在总结一下位移运算一些很有特点的操作：</p><ul><li>交集：A &amp; B</li><li>并集：A | B</li><li>差集： A &amp; (~B)</li></ul><p>最后，在网上发现一些关于位移运算技巧：<a href="https://www.zhihu.com/question/38206659">位运算有什么奇技淫巧？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式在字段验证场景中的使用</title>
      <link href="/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/"/>
      <url>/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式在字段验证场景中的使用"><a href="#责任链模式在字段验证场景中的使用" class="headerlink" title="责任链模式在字段验证场景中的使用"></a>责任链模式在字段验证场景中的使用</h1><p>最近在搬砖过程中有一个保存大表单的需求（搬砖CRUD常态），在保存这个大表单之前有一系列的检验（字段校验使用了JSR303），表单名不能和已有的重名、表单数量、同时还有一些字段是互斥不能同时选择的等等一些情况。</p><p>当时做这个的时候直接if else一把梭了，不过写到后面发现满屏的if else怎么看怎么别扭。</p><pre class=" language-Java"><code class="language-Java">public boolean validate(Query query) &#123;    if (表单名验证)&#123;    &#125; else if (表单数量验证) &#123;    &#125; else if (时间校验) &#123;    &#125;    ...&#125;</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote><p>顾名思义，责任链模式（Chain of Responsibility Pattern）<strong>为请求创建了一个接收者对象的链</strong>。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，<strong>通常每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会<strong>把相同的请求传给下一个接收者</strong>，依此类推。 </p><p>​                                                                                                                                        来源：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p></blockquote><p>简而言之，责任链模式就是一个对象经过一系列链接成链条的处理对象从而进行一系列处理。</p><p>从上面的定义可以看出责任链模式非常适合用来对同一个对象进行一系列处理的场合，如SpringMVC的拦截器使用场景，对Request进行拦截处理。对表单对象进行检验的场景也非常适合使用责任链模式。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在校验场景中，待处理对象就是表单对象，一系列的进行处理的对象则是一系列的校验器。因此首先需要一个校验器的接口，如下：</p><pre class=" language-Java"><code class="language-Java">public interface Validator &#123;    ValidateResult validate(ReportQuery reportQuery);&#125;</code></pre><p>对表单进行校验的校验器通过实现Validator接口即可：</p><pre class=" language-Java"><code class="language-Java">// 表单名验证public class ReportNameValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单名校验逻辑    &#125;&#125;// 表单数量验证public class ReportSizeValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单数量校验逻辑    &#125;&#125;</code></pre><p>链条上的进行处理的对象已经有了，现在需要一个可以把这些处理对象链接起来的并且可以按照链条顺序一一执行校验的对象：</p><pre class=" language-Java"><code class="language-Java">public class ReportValidator &#123;    // 检验器集合    private List<Validator> validators = new ArrayList<>();    // 添加校验器并链接成链条    public ReportValidator addValidator(Validator validator) &#123;        validators.add(validator);        return this;    &#125;    // 按照链条顺序执行校验    public ValidateResult validate(ReportQuery reportQuery) &#123;        ValidateResult validateResult = null;        for (Validator validator : validators) &#123;            validateResult = validator.validate(reportQuery);            if (!validateResult.isSuccess()) &#123;                return validateResult;            &#125;        &#125;        return validateResult;    &#125;&#125;</code></pre><p>然后，使用起来是这样子的：</p><pre class=" language-Java"><code class="language-Java">    @PostMapping("/urlpath")    public JsonCommonResponse fun(@RequestBody ReportQuery reportQuery) &#123;        // 校验        ReportValidator reportValidator = new ReportValidator().addValidator(new ReportNameValidator())                .addValidator(new ReportSizeValidator());        ValidateResult validateResult = reportValidator.validate(reportQuery);        if (!validateResult.isSuccess()) &#123;            return JsonCommonResponse.failRes(validateResult.getResultCode());        &#125;        // 业务逻辑    &#125;</code></pre><p>这样子使用起来十分方便，而且可读性也很好，扩展也十分方便，如果有新的校验逻辑，新建一个检验器类，添加到链条中即可。</p><p><strong>注：</strong>一些校验器的检验逻辑可能会依赖它前面的校验结果，可能会导致NPE（检验器的添加顺序也请务必仔细考虑）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式非常适合用于<strong>对一个对象进行一系列的处理</strong>，如过滤（过滤器），拦截（拦截器），检验（检验器）。</p><p>表单校验使用责任链模式和JSR303配合校验十分方便，而且可读性可维护性扩展性都挺不错。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ning0h2o的第一篇Blog</title>
      <link href="/ning0h2o-de-di-yi-pian-blog/"/>
      <url>/ning0h2o-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Ning0h2o的第一篇Blog"><a href="#Ning0h2o的第一篇Blog" class="headerlink" title="Ning0h2o的第一篇Blog"></a>Ning0h2o的第一篇Blog</h1><p>Hi，这里是Ning0h2o的blog，一枚刚进入职场的Java搬砖工程师~~</p><h2 id="一段简短的自我介绍"><a href="#一段简短的自我介绍" class="headerlink" title="一段简短的自我介绍"></a>一段简短的自我介绍</h2><p>ning0h2o（这个昵称可以转化成我的姓名哦，化学表达式+谐音这样子？），2020届大学毕业生，现在在狗东搬砖，唯一的兴趣就是打游戏打游戏打游戏了</p><h2 id="这个博客有什么内容？"><a href="#这个博客有什么内容？" class="headerlink" title="这个博客有什么内容？"></a>这个博客有什么内容？</h2><p>Java开发方面的技术记录文，类似个人学习笔记和开发笔记，大多会是一些知识点的罗列和简单说明，不会太深层次的去研讨技术（大佬请绕道）。</p><h2 id="写博客的理由"><a href="#写博客的理由" class="headerlink" title="写博客的理由"></a>写博客的理由</h2><ol><li>我记了很多笔记，有道云笔记现在大概有300来篇笔记了吧，但是都是一些零零散散的知识点，分类也乱七八糟的。而且在我记完笔记之后很少去看，到现在有些已经遗忘的差不多了。通过写博客的方式review和重新编排一下，同时也是把这些知识点构建成知识体系的有效途径</li><li>到现在已经入职一个多月了，对自己所在岗位也有一定的了解，我会在接下来一段相对长的时间从事搬砖的活（谁叫自己菜呢）。不过还好，开发用的那套技术栈和我掌握的重合性很高，很多知识点也是在我的笔记里有所记录。因此，写博客复习也有助于搬砖（误）</li><li>俗话说的好，“靠山山倒”。在开发这条路上总不能就靠我那百来多篇笔记了吧？那样子的话一辈子都是搬砖工了（笑）。我会去学习一些新技术，并且通过写博客的方式记录知识点和我的一些理解</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>能看到这儿的话，说明你是真的闲（笑）。从我上面写的内容你也大概看的出我文笔菜的一批，说来也惭愧，我高考语文差点不及格（苦笑）。在以后的博客写作中我会尽量保证语句通顺，在技术点说明这方面也会尽量保持正确性，个人理（忽）解（悠）处也会给出相应的标记（哈哈，不要被我忽悠了）</p><p>最后，十分感谢你能来到我的博客。如果你有什么建议或者想法对我说，可以在下方评论区留言，也可以加我企鹅号~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
