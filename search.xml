<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Logback最佳实践</title>
      <link href="/logback-zui-jia-shi-jian/"/>
      <url>/logback-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Logback最佳实践"><a href="#Logback最佳实践" class="headerlink" title="Logback最佳实践"></a>Logback最佳实践</h1><h2 id="Logback架构"><a href="#Logback架构" class="headerlink" title="Logback架构"></a>Logback架构</h2><p>Logback分为三个模块：Logback-core，Logback-classic和Logback-access。</p><p>Logback-core是其他两个模块实现的基础。Logback-classic相当于是Log4j的改进版，并且实现了Slf4J接口。Logback-access与Servlet容器集成，以提供HTTP访问日志功能（这个模块实际开发中很少用到）。</p><h2 id="Logback核心对象"><a href="#Logback核心对象" class="headerlink" title="Logback核心对象"></a>Logback核心对象</h2><p>Logback有三个核心对象：<strong>Logger</strong>、<strong>Appender</strong>、<strong>Layout</strong>。</p><p>Logger 位于 logback-classic 模块中， 而 Appender 和 Layout 位于 logback-core 中，这意味着， Appender 和 Layout 并不关心 Logger 的存在，不依赖于 Logger，同时也能看出， Logger 会依赖于 Appender 和 Layout 的协助，日志信息才能被正常打印出来。</p><ul><li><strong>Logger：</strong>日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。</li><li><strong>Appender：</strong>主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 数据库、 JMS和远程UNIX Syslog守护进程等。</li><li><strong>Layout：</strong>把事件转换成字符串，格式化的日志信息的输出。</li></ul><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>各个Logger 都被关联到一个 LoggerContext，LoggerContext负责制造Logger ，也负责以树结构排列各Logger 。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 Logger 名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个Logger 对象的引用。</p><h4 id="层次命名规则"><a href="#层次命名规则" class="headerlink" title="层次命名规则"></a>层次命名规则</h4><p>为了可以控制哪些信息需要输出，哪些信息不需要输出，Logback中引进了一个 分层 概念。每个 logger 都有一个 name，这个 name 的格式与 Java 语言中的包名格式相同。Logger 的 name 格式决定了多个 Logger 能够组成一个树状的结构，为了维护这个分层的树状结构，每个 logger 都被绑定到一个 Logger 上下文中，这个上下文负责厘清各个 logger 之间的关系。</p><p>例如，<code>"com.foo"</code>是<code>"com.foo.Bar"</code>的父Logger。同样， <code>"java"</code>是<code>"java.util"</code>的父Logger和<code>"java.util.Vector"</code>祖先Logger。</p><p>root Logger是所有Logger的祖先，这是 logback 内部维护的一个 logger，并非开发者自定义的 Logger 。</p><p>Logger有日志打印级别继承规则，对于一个未设置打印级别的Logger会向上寻找一个设置了日志打印级别的父Logger，直到root Logger。因此 必须为 root Logger指定日志打印级别。</p><h3 id="Appender-amp-Layout"><a href="#Appender-amp-Layout" class="headerlink" title="Appender &amp; Layout"></a>Appender &amp; Layout</h3><p>Appender 是绑定在 logger 上的，同时，一个 logger 可以绑定多个 Appender，意味着一条信息可以同时打印到不同的目的地去。例如，常见的做法是，日志信息既输出到控制台，同时也记录到日志文件中，这就需要为 logger 绑定两个不同的 logger。</p><p> logger 有继承关系，因此一个 logger 打印信息时的目的地 Appender 需要参考它的父亲和祖先。在 logback 中，默认情况下，如果一个 logger 打印一条信息，那么这条信息首先会打印至它自己的 Appender，然后打印至它的父亲和父亲以上的祖先的 Appender，但如果它的父亲设置了 <code>additivity = false</code>，那么这个 logger 除了打印至它自己的 Appender 外，只会打印至其父亲的 Appender，因为它的父亲的 <code>additivity</code> 属性置为了 false，开始变得忘祖忘宗了，所以这个 logger 只认它父亲的 Appender；此外，对于这个 logger 的父亲来说，如果父亲的 logger 打印一条信息，那么它只会打印至自己的 Appender中（如果有的话），因为父亲已经忘记了爷爷及爷爷以上的那些父辈了。</p><p>打印的日志除了有打印的目的地外，还有日志信息的展示格式。在 logback 中，用 Layout 来代表日志打印格式。比如说，PatternLayout 能够识别以下这条格式：</p><pre><code>%-4relative [%thread] %-5level %logger&amp;#123;32&amp;#125; - %msg%n</code></pre><p>然后打印出来的格式效果是：</p><pre><code>176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.</code></pre><p>第一个字段是自程序启动以来经过的毫秒数。第二个字段是发出日志请求的线程。第三个字段是日志打印级别。第四个字段是Logger名称。“-”之后的文本是日志消息。</p><h2 id="Logback加载流程"><a href="#Logback加载流程" class="headerlink" title="Logback加载流程"></a>Logback加载流程</h2><ol><li>Logback尝试在classpath下找到一个名为<em>logback-test.xml</em> 的文件 。（xml配置）</li><li>如果找不到上述文件，尝试在classpath找到一个名为<em>logback.groovy</em> 的文件 。（groovy配置）</li><li>如果找不到上述文件，尝试在classpath中找到一个名为<em>logback.xml</em>的文件。</li><li>如果上述的文件都找不到，则 logback 会使用 JDK 的 SPI 机制查找 META-INF/services/ch.qos.logback.classic.spi.Configurator 中的 logback 配置实现类，这个实现类必须实现 <code>Configuration</code> 接口，使用它的实现来进行配置。（编程式配置）</li><li>如果以上方法均未成功，则Logback将使用自带的 <code>BasicConfigurator</code> 进行自动配置。该配置构造一个<code>ConsoleAppender</code>用于向控制台输出日志，默认日志输出格式为”<code>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</code>“，日志打印级别为<strong>Debug</strong>。</li></ol><p>在Maven工程中，一般将 <em>logback-test.xml</em>放在<em>src / test / resources</em> 文件夹下，Maven将确保它不会包含在生成的工件中。因此，您可以在测试期间使用其他配置文件，即<em>logback-test.xml</em>，在生产环境中使用另一个文件，即<em>logback.xml</em>。</p><p>logback 启动的时候解析配置文件大概需要 100 毫秒的时间，如果希望更快启动，可以采用 SPI 的方式。</p><h2 id="Logback的默认配置"><a href="#Logback的默认配置" class="headerlink" title="Logback的默认配置"></a>Logback的默认配置</h2><p> <code>BasicConfigurator</code> 默认配置可以使用以下配置文件表述：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- encoders are assigned the type         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d<span class="token entity" title="&#123;">&amp;#123;</span>HH:mm:ss.SSS<span class="token entity" title="&#125;">&amp;#125;</span> [%thread] %-5level %logger<span class="token entity" title="&#123;">&amp;#123;</span>36<span class="token entity" title="&#125;">&amp;#125;</span> - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debug<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h2 id="Logback配置文件语法"><a href="#Logback配置文件语法" class="headerlink" title="Logback配置文件语法"></a>Logback配置文件语法</h2><p>配置文件的最基本结构可以描述为<code>&lt;configuration&gt;</code>元素，包含零个或多个<code>&lt;appender&gt;</code>元素，然后是零个或多个<code>&lt;logger&gt;</code>元素，然后是最多一个<code>&lt;root&gt;</code>元素。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--    scan 设置为true（默认值） 配置文件变更会重新加载    scanPeriod 检测日志是否修改时间间隔    debug 是否打印logback内部日志--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span> <span class="token attr-name">scan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scanPeriod</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60 seconds<span class="token punctuation">"</span></span> <span class="token attr-name">debug</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        property 自定义定义变量值            name  变量名            value 变量值           scope 作用域                  local 作用域在配置文件内有效                   context 作用域的有效范围延伸至 logger context                   system 作用域的范围最广，整个 JVM 内都有效。        --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>context<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>glmapper-name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>glmapper-demo<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--         也可以引用外部配置文件，配置文件必须为 key-value 型。    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>resource1.properties<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--        contextName logger上下文 用于区分不同应用程序的记录，默认为default    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextName</span><span class="token punctuation">></span></span>$<span class="token entity" title="&#123;">&amp;#123;</span>glmapper-name<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextName</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        appender 负责写日志的组件    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.encoder.PatternLayoutEncoder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Pattern</span><span class="token punctuation">></span></span>%d<span class="token entity" title="&#123;">&amp;#123;</span>HH:mm:ss.SSS<span class="token entity" title="&#125;">&amp;#125;</span> %-5level %logger<span class="token entity" title="&#123;">&amp;#123;</span>80<span class="token entity" title="&#125;">&amp;#125;</span> - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        用于设置某一个包或某个类日志打印级别以及制定的appender    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        根logger 只有一个level属性，默认为debug    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h3 id="配置Logger"><a href="#配置Logger" class="headerlink" title="配置Logger"></a>配置Logger</h3><p>使用<code>&lt;logger&gt;</code>元素配置Logger，Logger配置需注意Logger的级别继承特性。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.ning.test<span class="token punctuation">"</span></span>        <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>GLMAPPER-LOGGERONE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span></code></pre><ul><li><strong>name：</strong>强制性属性，指定Logger名称。可以是某个包或者具体的某个类。</li><li><strong>level：</strong>日志打印级别（<code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>ALL</code> 和 <code>OFF</code>）。特殊值<code>INHERITED</code>或者同义词<code>NULL</code>，代表强制执行父级的级别。如果没有设置此属性，那么当前Logger 将会继承父级的级别。</li><li><strong>addtivity：</strong>是否向上级Logger传递打印信息。默认是<code>true</code>。</li><li><strong>appender-ref：</strong>指定具体的<code>appender</code>。可包含0个或多个<code>appender</code>。</li></ul><h3 id="配置根Logger"><a href="#配置根Logger" class="headerlink" title="配置根Logger"></a>配置根Logger</h3><p>使用<code>&lt;root&gt;</code>元素配置根Logger。</p><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debug<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p><code>&lt;root&gt;</code>只支持单个属性，即日志打印级别属性，可选值有不区分大小写的字符串TRACE，DEBUG，INFO，WARN，ERROR，ALL或OFF吗，默认值为DEBUG。</p><h3 id="配置Appender"><a href="#配置Appender" class="headerlink" title="配置Appender"></a>配置Appender</h3><p>使用<code>&lt;appender&gt;</code> 元素配置appender。</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--        appender种类      ConsoleAppender 打印到控制台                         FileAppender   打印到文件                         RollingFileAppender 上面的子类，滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>NING-LOGGERONE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 文件追加 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>append</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>append</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--            filter种类    ThresholdFilter 临界值过滤器 过滤掉低于指定临界值的日志                         LevelFilter    级别过滤器，根据日志级别进行过滤        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>            ./logs/ning-log-logback/ning-loggerone.log        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--            rollingPolicy滚动策略  只有appender为RollingFileAppender才有效 涉及文件的移动和重命名                    TimeBasedRollingPolicy 时间滚动策略 常用                    FixedWindowRollingPolicy 固定窗口算法重命名文件的滚动策略        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件输出的文件名:按天回滚 daily --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FileNamePattern</span><span class="token punctuation">></span></span>./logs/ning-log-logback/ning-loggerone.log.%d<span class="token entity" title="&#123;">&amp;#123;</span>yyyy-MM-dd<span class="token entity" title="&#125;">&amp;#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FileNamePattern</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 保留30天 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MaxHistory</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MaxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--            对记录事件进行格式化 把日志信息转换成字节数组 把字节数组写入到输出流        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.encoder.PatternLayoutEncoder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d<span class="token entity" title="&#123;">&amp;#123;</span>yyyy-MM-dd HH:mm:ss.SSS<span class="token entity" title="&#125;">&amp;#125;</span> [%thread] %-5level %logger<span class="token entity" title="&#123;">&amp;#123;</span>50<span class="token entity" title="&#125;">&amp;#125;</span> - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span></code></pre><ul><li><p><strong>name：</strong>必要属性。指定<code>appender</code>名称。</p></li><li><p><strong>class：</strong>指定<code>appender</code>类实例化的全限定名。</p><ul><li>ConsoleAppender：打印到控制台</li><li>FileAppender：打印到文件的</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul></li><li><p><strong><append>：</append></strong>为true，日志文件追加。为false，覆写。默认为true。</p></li><li><p><file>：定义日志文件路径和文件名。</file></p></li><li><p><filter>：对日志进行过滤器。可以添加多个filter，按配置顺序过滤。</filter></p><ul><li><p>ThresholdFilter：临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回<code>NEUTRAL</code>；当日志级别低于临界值时，日志会被拒绝。</p></li><li><p>LevelFilter：级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据<code>onMath</code>(用于配置符合过滤条件的操作) 和 <code>onMismatch</code>(用于配置不符合过滤条件的操作)接收或拒绝日志。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span> </code></pre></li></ul></li><li><p><rollingpolicy>：滚动策略，只有当<code>appender</code>为RollingFileAppender时，此标签配置有效。涉及文件的移动和重命名。</rollingpolicy></p><ul><li><p>TimeBasedRollingPolicy：最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动。下面这段配置表明<strong>每天生成一个日志文件，保存30天的日志文件</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span>     <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--日志文件输出的文件名:按天回滚 daily --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FileNamePattern</span><span class="token punctuation">></span></span>        $<span class="token entity" title="&#123;">&amp;#123;</span>logging.path<span class="token entity" title="&#125;">&amp;#125;</span>/glmapper-spring-boot/glmapper-loggerone.log.%d<span class="token entity" title="&#123;">&amp;#123;</span>yyyy-MM-dd<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FileNamePattern</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MaxHistory</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MaxHistory</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span></code></pre></li><li><p>FixedWindowRollingPolicy：根据固定窗口算法重命名文件的滚动策略。</p></li></ul></li><li><p><encoder>：对记录事件进行格式化。把日志信息转换成字节数组，再把字节数组写入到输出流。</encoder></p></li></ul><h2 id="LogBack运行流程"><a href="#LogBack运行流程" class="headerlink" title="LogBack运行流程"></a>LogBack运行流程</h2><p>当用户调用名为com.wombat的Logger的info方法时，Logback内部运行流程如下。</p><p><img src="logback%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.gif"></p><ol><li><strong>获得过滤器链：</strong>过滤某些日志打印请求。过滤器返回结果为<strong>DENY</strong>时，取消打印请求。为<strong>NEUTRAL</strong>时，进入下一个过滤器。为ACCEPT时，直接跳到步骤3。</li><li><strong>检查日志级别以决定是否继续打印</strong>：logback将Logger的有效级别与请求级别进行比较。</li><li><strong>创建一个 <code>LoggingEvent</code> 对象：</strong><code>LoggingEvent</code>对象包含请求的所有相关参数，例如请求的Logger，日志打印级别，日志消息本身，可能与请求一起传递的异常，当前时间，当前线程，有关发出日志记录请求的类的各种数据以及<code>MDC</code>。</li><li><strong>调用 Appenders：</strong>创建<code>LoggingEvent</code>对象后，logback将调用<code>doAppend()</code>所有适用的appender 的方法，即从logger上下文继承的appender。</li><li><strong>进行日志信息格式化：</strong>被调用的Appender负责格式化日志记录事件。但是，一些（但不是全部）Appender将格式化日志记录事件的任务委托给Layout。Layout会格式化<code>LoggingEvent</code>实例，并以字符串形式返回结果。请注意，某些Appender（例如） <code>SocketAppender</code>不会将日志记录事件转换为字符串，而是将其序列化。因此，它们没有Layout，也不需要Layout。</li><li><strong>发送 <code>LoggingEvent</code> 到对应的目的地</strong>：日志记录事件完全格式化后，每个Appender将其发送到其目的地。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志体系概述</title>
      <link href="/java-ri-zhi-ti-xi-gai-shu/"/>
      <url>/java-ri-zhi-ti-xi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java日志体系概述"><a href="#Java日志体系概述" class="headerlink" title="Java日志体系概述"></a>Java日志体系概述</h1><p>平时自己写代码很少使用日志，对Java日志这方面的知识也有所欠缺。现在工作中要求在代码中使用合理地打上一些日志，这几天也有去了解Java日志有关的一些知识，这篇文章也是对最近几天的学习进行一些总结。</p><h2 id="为什么要有Java日志？"><a href="#为什么要有Java日志？" class="headerlink" title="为什么要有Java日志？"></a>为什么要有Java日志？</h2><p>可能在写程序你也会有和我一些的疑问，为什么要用Java日志这类东西，如果要输出程序运行细节的话，使用<code>System.out</code>或者 <code>System.err</code>不就行了。这样子的想法大概我们的前辈也有经历过，在JDK1.3及以前版本中Java打日志只能使用以上方法输出到STDOUT流和STDERR流。但是其实使用这种方式记录日志很不灵活，例如你不能很轻松的更改日志级别、关闭日志或者对日志进行自定义操作。于是在1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即<strong>Log4j</strong>。后来Log4j成为Apache基金会项目中的一员。这是<a href="http://logging.apache.org/log4j/1.2/manual.html">Log4j官网</a>关于Log4j的介绍，同时也说明了为什么要使用日志记录。总结如下：</p><ul><li>调试代码一种低技术含量的方法就是将日志语句插入到代码中。在大多中场景中，这也可能是唯一的方法，因为调试器不总是可用或者不适用（对于多线程应用程序和分布式应用通常是这种情况）</li><li>精确记录应用程序运行的上下文环境，一旦插入到代码中，日志输出的生成无需人工干预</li><li>日志输出可以保存在永久性介质（文件磁盘）中，以便以后进行研究</li><li>除了在开发周期中使用它外，足够丰富的日志记录包也可以视为审核工具</li></ul><p>当然日志记录除了有以上优点外，也有它的缺点，比如记录日志可能会使程序运行变慢。</p><h2 id="Java日志体系介绍"><a href="#Java日志体系介绍" class="headerlink" title="Java日志体系介绍"></a>Java日志体系介绍</h2><p>从96年（Log4j）到现在，可供我们使用的日志记录工具已经很多了，JUL(Java Util Logging)、JCL(Jakarta Commons Logging)、Log4j、SLF4J、Logback、Log4j2 等等。多得不知道如何去选择这些日志工具，甚至有点混乱了。在一个项目中如果你依赖了很多第三方库，你就会发现一件“有趣”的事情，你的应用程序可能会有好几个日志工具共存或者第三库使用的日志工具和你项目中使用的不一致，因此你必须耐心的去排除掉这些日志工具使其统一，如果没有对Java日志体系建立起足够的了解的话，这不是一件容易的事。(≖_≖ )</p><p>为了厘清现在所使用的Java日志工具，回溯到过去，了解Java日志体系发展历史是一种最为有效的途径了。</p><h3 id="日志体系开端——Log4j"><a href="#日志体系开端——Log4j" class="headerlink" title="日志体系开端——Log4j"></a>日志体系开端——Log4j</h3><p>前面有说到，JDK开始是没有内置日志工具的，只能通过<code>System.out</code>或者 <code>System.err</code>记录程序运行状况。在1996年，Java才有了日志工具，<strong>Log4j</strong>。Log4j一经推出，就成为了业内的日志标杆。Log4j后来成为了Apache基金会项目中的一员，这也为后来的混乱局面埋下了伏笔（不是“官方正统”）。</p><h3 id="混乱开端——Java“正统”日志工具JUL"><a href="#混乱开端——Java“正统”日志工具JUL" class="headerlink" title="混乱开端——Java“正统”日志工具JUL"></a>混乱开端——Java“正统”日志工具JUL</h3><p>在JDK1.4，sun公司推出了Java“正统”日志库**JUL(Java Util Logging)**企图对抗Log4j，Java日志工具局面开始混乱了。</p><h3 id="一统天下的“暴君”——JCL-Jakarta-Commons-Logging"><a href="#一统天下的“暴君”——JCL-Jakarta-Commons-Logging" class="headerlink" title="一统天下的“暴君”——JCL(Jakarta Commons Logging)"></a>一统天下的“暴君”——JCL(Jakarta Commons Logging)</h3><p>在<strong>JUL(Java Util Logging)**出现后不久，开发人员就意识到需要一个统一通用的日志接口。这个时候，Apache推出了</strong>JCL（Jakarta Commons Logging）**，日志框架即日志抽象层，同时提供一个默认实现Simple Log。JCL的逻辑是这样子的：JCL将作为所有日志工具的框架（抽象访问层），让实际记录日志的日志工具去实现它的抽象，这样子只要你使用日志代码依赖的是JCL的接口，你就可以很方便的在各种日志工具做切换。</p><p>当然统一日志局面也是要有“相应能力”的，显然JCL在这方面做得不够好，开发人员发现了JCL还不够好，有些人甚至认为JCL造成的问题比解决的问题还多。</p><h3 id="英雄登场——Slf4j-amp-Logback"><a href="#英雄登场——Slf4j-amp-Logback" class="headerlink" title="英雄登场——Slf4j&amp;Logback"></a>英雄登场——Slf4j&amp;Logback</h3><p>这里说的是“英雄”是指<strong>Ceki Gülcü</strong>（同时也是Log4j的作者），他觉得JCL不够好，所以开发出了一套更为优秀的日志框架<strong>Slf4j（Simple Logging Facade for Java）</strong>，同时也提供一个比Log4j更为优秀的默认实现<strong>Logback</strong>。为了适配现有一些日志工具（Log4j，JUL），<strong>Ceki Gülcü</strong>也为一系列日志工具提供了桥接包，如slf4j-log4j12（Slf4j-Log4j桥接包）。当然只有日志工具的桥接包是不够的，如果当前应用使用了JCL日志框架，现在要使用Slf4j作为统一日志框架输出日志怎么办？桥接，当前桥接包不够那就再加一个，于是就有了slf4j-over-jcl（slf4j替换JCL）。</p><p>于是，现有的日志工具和日志框架的使用逻辑如下：</p><p><img src="Java%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0_1.png"></p><p>图片来源：<a href="https://segmentfault.com/img/bVbAMVm">https://segmentfault.com/img/bVbAMVm</a></p><p><strong>注：</strong>使用桥接包时一定要注意避免环形依赖问题（会造成StackOverflow）。日志框架和日志工具或日志框架之间的两个桥接包一定不能同时存在。slf4j-xxx包作用是接口使用slf4j这一套，底层日志实现使用具体的xxx； xxx-over-slf4j包作用是对于xxx调用会转调slf4j接口。</p><h3 id="王者归来——Log4j-2（Log4j-api-amp-Log4j-core）"><a href="#王者归来——Log4j-2（Log4j-api-amp-Log4j-core）" class="headerlink" title="王者归来——Log4j 2（Log4j-api&amp;Log4j-core）"></a>王者归来——Log4j 2（Log4j-api&amp;Log4j-core）</h3><p>你以为这样子就结束了？为了维护在 Java 日志江湖的地位，Apache重写了Log4j 1.x，成立了新的项目Log4j 2, 且Log4j 2具有Logback的所有特性。<strong>Log4j-api</strong>作为全新的日志框架，<strong>Log4j-core</strong>则作为它的默认实现，除了具有Logback所有特性之外，还新增了很多其他新特性，具体在<a href="http://logging.apache.org/log4j/2.x/index.html">Log4j 2官网</a>。当然，随着全新的日志框架和日志工具的出现，这次同样也带来了一大堆桥接包。具体如下：</p><p><img src="Java%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0_2.png"></p><p>图片来源：<a href="https://segmentfault.com/img/bVbAMVm">https://segmentfault.com/img/bVbAMVm</a></p><p>以上就是Java日志体系各阶段的发展历史了，到今天已然变成了“三分天下”的混乱局面。只怪当初的Sun公司不够争气，要是当初能像JDBC一样提出一套Java日志规范（接口）就没后面这么多事了。所以，<strong>面向接口编程是非常重要的</strong>！！！</p><h2 id="日志框架和工具的选择"><a href="#日志框架和工具的选择" class="headerlink" title="日志框架和工具的选择"></a>日志框架和工具的选择</h2><p>根据我写这篇文章在网上搜索文章的经历，目前<strong>Slf4j+Logback</strong>组合是当前最热门，刚好我工作中使用的也是这套。</p><h2 id="如何排除项目中依赖的第三方包的日志依赖"><a href="#如何排除项目中依赖的第三方包的日志依赖" class="headerlink" title="如何排除项目中依赖的第三方包的日志依赖"></a>如何排除项目中依赖的第三方包的日志依赖</h2><p>在项目开发过程中，项目会根据需要引入一些第三方库，例如常用的 Spring，而 Spring 本身的日志实现使用了commons-logging（JCL），如果想使用 Slf4j+Logback 组合，这时候需要在项目中将 commons-logging排除掉，通常会用到以下 3 种方案，各有利弊，可以根据项目的实际情况选择最适合自己项目的解决方案。</p><ul><li><p>采用 maven 的 exclusion 方案这种方案优点是 exclusion 是 maven 原生提供的，不足之处是如果有多个组件都依赖了 commons-logging，则需要在很多处增加 exclusion，比较繁琐。（我一般使用这种方法）</p></li><li><p>在 maven 声明 commons-logging 的 scope 为 provided，这种方案虽然简洁，但也有缺点，在调试代码时有可能导致 IDE 将 commons-logging 放置在 classpath 下，从而导致程序运行时出现异常。</p></li><li><p>在 maven 私服中增加类似于 99.0-does-not-exist 这种虚拟的版本号。这种方案好处在于声明方式比较简单，用 IDE 调试代码时也不会出现问题，不足之处是 99.0-does-not-exist 这种版本是 maven 中央仓库中可能不存在，需要发布到自己的 maven 私服中。</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>99.0-does-not-exist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位移在枚举中的应用</title>
      <link href="/wei-yi-zai-mei-ju-zhong-de-ying-yong/"/>
      <url>/wei-yi-zai-mei-ju-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="位移在枚举中的应用"><a href="#位移在枚举中的应用" class="headerlink" title="位移在枚举中的应用"></a>位移在枚举中的应用</h1><p>最近在公司代码中发现一个枚举类中使用了位移来表示枚举值，不是很能理解为何这样设置，遂去问了度娘和老同事。大概意思就是存在多个枚举组合使用的情况下使用位移能很方便的分辨出是哪些枚举。</p><pre class=" language-Java"><code class="language-Java">public enum BusinessType &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);&#125;</code></pre><p>如上是一个产品线枚举，如果想判断某个产品是否同时属于产品线A和产品线B，可以这样子来判断：</p><pre class=" language-Java"><code class="language-Java">    Integer type = BusinessType.A.getCode() + BusinessType.B.getCode();    if ((obj.getBusinessType() & type) == type) &#123;    &#125;</code></pre><h2 id="举一反三，在检验场景中的使用"><a href="#举一反三，在检验场景中的使用" class="headerlink" title="举一反三，在检验场景中的使用"></a>举一反三，在检验场景中的使用</h2><p>接上次的检验场景，表单对象中的用户可选的标签中有几个有冲突不能同时选择，在保存表单对象必须对这些情况进行检验。</p><h3 id="1-构建枚举类"><a href="#1-构建枚举类" class="headerlink" title="1.构建枚举类"></a>1.构建枚举类</h3><p>很幸运，公司代码中已经有用户选择标签的枚举类了，但是没有可供使用的位移枚举值，因此扩展一下，如下：</p><pre class=" language-Java"><code class="language-Java">public enum Label &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);    D("DDD", 1 << 3);&#125;</code></pre><h3 id="2-设计冲突规则-amp-计算校验和"><a href="#2-设计冲突规则-amp-计算校验和" class="headerlink" title="2.设计冲突规则&amp;计算校验和"></a>2.设计冲突规则&amp;计算校验和</h3><p>比如，A和B不能同时选择校验规则，至少选择一个标签，当然也适用比较复杂的校验规则，如必须ABCD之间自由组合，这些规则可以按如下设计：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// AB不能同时选择</span>    Integer ABConflictRule <span class="token operator">=</span> Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 至少选择一个</span>    Integer leastOneCheckedRule <span class="token operator">=</span> ABConflictRule <span class="token operator">+</span> Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> complexCheckRule <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>                            Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>冲突规则设计完毕之后，就需要计算所选择标签的校验和了，</p><pre class=" language-Java"><code class="language-Java">    int checkSum = 0;    for (Label label : query.getLabels()) &#123;        checkSum += Lable.descOf(label.getDesc).getCode();    &#125;</code></pre><h3 id="3-进行校验"><a href="#3-进行校验" class="headerlink" title="3.进行校验"></a>3.进行校验</h3><p>对校验和和冲突规则使用位移运算，然后根据位移运算之后的结果判断是否冲突，如：</p><pre class=" language-Java"><code class="language-Java">    if ((ABConflictRule & checkSum) == ABConflictRule) &#123;        System.out.println("AB冲突了");    &#125;    if ((leastOneCheckedRule & checkSum) == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 也可以这样    if (chcksum == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 至少选择一个标签 && 不能选择一个标签 = ABCD之间自由组合    if ((leastOneCheckedRule & checkSum) == 0 && complexCheckRule.contains(checkSum)) &#123;        System.out.println("标签之间没有自由组合");    &#125;</code></pre><p>最后一个校验稍微有点复杂，需要进行一下换算。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位移运算在工作中很少使用到，以前只知道位移效率高，可以用来替代 乘法 和 除法。对位移运算的理解和应用也仅仅只限于熟悉运算规则并进行计算而已，很难想到上面这种通过位移来进行筛选。其实关于上面这些操作在离散数学中都有介绍，只能怪自己当初摸鱼了（囧）。。。</p><p>现在总结一下位移运算一些很有特点的操作：</p><ul><li>交集：A &amp; B</li><li>并集：A | B</li><li>差集： A &amp; (~B)</li></ul><p>最后，在网上发现一些关于位移运算技巧：<a href="https://www.zhihu.com/question/38206659">位运算有什么奇技淫巧？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式在字段验证场景中的使用</title>
      <link href="/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/"/>
      <url>/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式在字段验证场景中的使用"><a href="#责任链模式在字段验证场景中的使用" class="headerlink" title="责任链模式在字段验证场景中的使用"></a>责任链模式在字段验证场景中的使用</h1><p>最近在搬砖过程中有一个保存大表单的需求（搬砖CRUD常态），在保存这个大表单之前有一系列的检验（字段校验使用了JSR303），表单名不能和已有的重名、表单数量、同时还有一些字段是互斥不能同时选择的等等一些情况。</p><p>当时做这个的时候直接if else一把梭了，不过写到后面发现满屏的if else怎么看怎么别扭。</p><pre class=" language-Java"><code class="language-Java">public boolean validate(Query query) &#123;    if (表单名验证)&#123;    &#125; else if (表单数量验证) &#123;    &#125; else if (时间校验) &#123;    &#125;    ...&#125;</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote><p>顾名思义，责任链模式（Chain of Responsibility Pattern）<strong>为请求创建了一个接收者对象的链</strong>。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，<strong>通常每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会<strong>把相同的请求传给下一个接收者</strong>，依此类推。 </p><p>​                                                                                                                                        来源：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p></blockquote><p>简而言之，责任链模式就是一个对象经过一系列链接成链条的处理对象从而进行一系列处理。</p><p>从上面的定义可以看出责任链模式非常适合用来对同一个对象进行一系列处理的场合，如SpringMVC的拦截器使用场景，对Request进行拦截处理。对表单对象进行检验的场景也非常适合使用责任链模式。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在校验场景中，待处理对象就是表单对象，一系列的进行处理的对象则是一系列的校验器。因此首先需要一个校验器的接口，如下：</p><pre class=" language-Java"><code class="language-Java">public interface Validator &#123;    ValidateResult validate(ReportQuery reportQuery);&#125;</code></pre><p>对表单进行校验的校验器通过实现Validator接口即可：</p><pre class=" language-Java"><code class="language-Java">// 表单名验证public class ReportNameValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单名校验逻辑    &#125;&#125;// 表单数量验证public class ReportSizeValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单数量校验逻辑    &#125;&#125;</code></pre><p>链条上的进行处理的对象已经有了，现在需要一个可以把这些处理对象链接起来的并且可以按照链条顺序一一执行校验的对象：</p><pre class=" language-Java"><code class="language-Java">public class ReportValidator &#123;    // 检验器集合    private List<Validator> validators = new ArrayList<>();    // 添加校验器并链接成链条    public ReportValidator addValidator(Validator validator) &#123;        validators.add(validator);        return this;    &#125;    // 按照链条顺序执行校验    public ValidateResult validate(ReportQuery reportQuery) &#123;        ValidateResult validateResult = null;        for (Validator validator : validators) &#123;            validateResult = validator.validate(reportQuery);            if (!validateResult.isSuccess()) &#123;                return validateResult;            &#125;        &#125;        return validateResult;    &#125;&#125;</code></pre><p>然后，使用起来是这样子的：</p><pre class=" language-Java"><code class="language-Java">    @PostMapping("/urlpath")    public JsonCommonResponse fun(@RequestBody ReportQuery reportQuery) &#123;        // 校验        ReportValidator reportValidator = new ReportValidator().addValidator(new ReportNameValidator())                .addValidator(new ReportSizeValidator());        ValidateResult validateResult = reportValidator.validate(reportQuery);        if (!validateResult.isSuccess()) &#123;            return JsonCommonResponse.failRes(validateResult.getResultCode());        &#125;        // 业务逻辑    &#125;</code></pre><p>这样子使用起来十分方便，而且可读性也很好，扩展也十分方便，如果有新的校验逻辑，新建一个检验器类，添加到链条中即可。</p><p><strong>注：</strong>一些校验器的检验逻辑可能会依赖它前面的校验结果，可能会导致NPE（检验器的添加顺序也请务必仔细考虑）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式非常适合用于<strong>对一个对象进行一系列的处理</strong>，如过滤（过滤器），拦截（拦截器），检验（检验器）。</p><p>表单校验使用责任链模式和JSR303配合校验十分方便，而且可读性可维护性扩展性都挺不错。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ning0h2o的第一篇Blog</title>
      <link href="/ning0h2o-de-di-yi-pian-blog/"/>
      <url>/ning0h2o-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Ning0h2o的第一篇Blog"><a href="#Ning0h2o的第一篇Blog" class="headerlink" title="Ning0h2o的第一篇Blog"></a>Ning0h2o的第一篇Blog</h1><p>Hi，这里是Ning0h2o的blog，一枚刚进入职场的Java搬砖工程师~~</p><h2 id="一段简短的自我介绍"><a href="#一段简短的自我介绍" class="headerlink" title="一段简短的自我介绍"></a>一段简短的自我介绍</h2><p>ning0h2o（这个昵称可以转化成我的姓名哦，化学表达式+谐音这样子？），2020届大学毕业生，现在在狗东搬砖，唯一的兴趣就是打游戏打游戏打游戏了</p><h2 id="这个博客有什么内容？"><a href="#这个博客有什么内容？" class="headerlink" title="这个博客有什么内容？"></a>这个博客有什么内容？</h2><p>Java开发方面的技术记录文，类似个人学习笔记和开发笔记，大多会是一些知识点的罗列和简单说明，不会太深层次的去研讨技术（大佬请绕道）。</p><h2 id="写博客的理由"><a href="#写博客的理由" class="headerlink" title="写博客的理由"></a>写博客的理由</h2><ol><li>我记了很多笔记，有道云笔记现在大概有300来篇笔记了吧，但是都是一些零零散散的知识点，分类也乱七八糟的。而且在我记完笔记之后很少去看，到现在有些已经遗忘的差不多了。通过写博客的方式review和重新编排一下，同时也是把这些知识点构建成知识体系的有效途径</li><li>到现在已经入职一个多月了，对自己所在岗位也有一定的了解，我会在接下来一段相对长的时间从事搬砖的活（谁叫自己菜呢）。不过还好，开发用的那套技术栈和我掌握的重合性很高，很多知识点也是在我的笔记里有所记录。因此，写博客复习也有助于搬砖（误）</li><li>俗话说的好，“靠山山倒”。在开发这条路上总不能就靠我那百来多篇笔记了吧？那样子的话一辈子都是搬砖工了（笑）。我会去学习一些新技术，并且通过写博客的方式记录知识点和我的一些理解</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>能看到这儿的话，说明你是真的闲（笑）。从我上面写的内容你也大概看的出我文笔菜的一批，说来也惭愧，我高考语文差点不及格（苦笑）。在以后的博客写作中我会尽量保证语句通顺，在技术点说明这方面也会尽量保持正确性，个人理（忽）解（悠）处也会给出相应的标记（哈哈，不要被我忽悠了）</p><p>最后，十分感谢你能来到我的博客。如果你有什么建议或者想法对我说，可以在下方评论区留言，也可以加我企鹅号~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
