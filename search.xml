<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java日志概述</title>
      <link href="/java-ri-zhi-gai-shu/"/>
      <url>/java-ri-zhi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java日志概述"><a href="#Java日志概述" class="headerlink" title="Java日志概述"></a>Java日志概述</h1><p>平时自己写代码很少使用日志，对Java日志这方面的知识也有所欠缺。现在工作中要求在代码中使用合理地打上一些日志，这几天也有去了解Java日志有关的一些知识，这篇文章也是对最近几天的学习进行一些总结。</p><h2 id="为什么要有Java日志？"><a href="#为什么要有Java日志？" class="headerlink" title="为什么要有Java日志？"></a>为什么要有Java日志？</h2><p>可能在写程序你也会有和我一些的疑问，为什么要用Java日志这类东西，如果要输出程序运行细节的话，使用<code>System.out</code>或者 <code>System.err</code>不就行了。这样子的想法大概我们的前辈也有经历过，在JDK1.3及以前版本中Java打日志只能使用以上方法输出到STDOUT流和STDERR流。但是其实使用这种方式记录日志很不灵活，例如你不能很轻松的更改日志级别、关闭日志或者对日志进行自定义操作。于是在1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即<strong>Log4j</strong>。后来Log4j成为Apache基金会项目中的一员。这是<a href="http://logging.apache.org/log4j/1.2/manual.html">Log4j官网</a>关于Log4j的介绍，同时也说明了为什么要使用日志记录。总结如下：</p><ul><li>调试代码一种低技术含量的方法就是将日志语句插入到代码中。在大多中场景中，这也可能是唯一的方法，因为调试器不总是可用或者不适用（对于多线程应用程序和分布式应用通常是这种情况）</li><li>精确记录应用程序运行的上下文环境，一旦插入到代码中，日志输出的生成无需人工干预</li><li>日志输出可以保存在永久性介质（文件磁盘）中，以便以后进行研究</li><li>除了在开发周期中使用它外，足够丰富的日志记录包也可以视为审核工具</li></ul><p>当然日志记录除了有以上优点外，也有它的缺点，比如记录日志可能会使程序运行变慢。</p><h2 id="Java日志体系介绍"><a href="#Java日志体系介绍" class="headerlink" title="Java日志体系介绍"></a>Java日志体系介绍</h2><p>从96年（Log4j）到现在，可供我们使用的日志记录工具已经很多了，JUL(Java Util Logging)、JCL(Jakarta Commons Logging)、Log4j、SLF4J、Logback、Log4j2 等等。多得不知道如何去选择这些日志工具，甚至有点混乱了。在一个项目中如果你依赖了很多第三方库，你就会发现一件“有趣”的事情，你的应用程序可能会有好几个日志工具共存或者第三库使用的日志工具和你项目中使用的不一致，因此你必须耐心的去排除掉这些日志工具使其统一，如果没有对Java日志体系建立起足够的了解的话，这不是一件容易的事。(≖_≖ )</p><p>为了厘清现在所使用的Java日志工具，回溯到过去，了解Java日志体系发展历史是一种最为有效的途径了。</p><h3 id="日志体系开端——Log4j"><a href="#日志体系开端——Log4j" class="headerlink" title="日志体系开端——Log4j"></a>日志体系开端——Log4j</h3><p>前面有说到，JDK开始是没有内置日志工具的，只能通过<code>System.out</code>或者 <code>System.err</code>记录程序运行状况。在1996年，Java才有了日志工具，<strong>Log4j</strong>。Log4j一经推出，就成为了业内的日志标杆。Log4j后来成为了Apache基金会项目中的一员，这也为后来的混乱局面埋下了伏笔（不是“官方正统”）。</p><h3 id="混乱开端——Java“正统”日志工具JUL"><a href="#混乱开端——Java“正统”日志工具JUL" class="headerlink" title="混乱开端——Java“正统”日志工具JUL"></a>混乱开端——Java“正统”日志工具JUL</h3><p>在JDK1.4，sun公司推出了Java“正统”日志库**JUL(Java Util Logging)**企图对抗Log4j，Java日志工具局面开始混乱了。</p><h3 id="一统天下的“暴君”——JCL-Jakarta-Commons-Logging"><a href="#一统天下的“暴君”——JCL-Jakarta-Commons-Logging" class="headerlink" title="一统天下的“暴君”——JCL(Jakarta Commons Logging)"></a>一统天下的“暴君”——JCL(Jakarta Commons Logging)</h3><p>在<strong>JUL(Java Util Logging)**出现后不久，开发人员就意识到需要一个统一通用的日志接口。这个时候，Apache推出了</strong>JCL（Jakarta Commons Logging）**，日志框架即日志抽象层，同时提供一个默认实现Simple Log。JCL的逻辑是这样子的：JCL将作为所有日志工具的框架（抽象访问层），让实际记录日志的日志工具去实现它的抽象，这样子只要你使用日志代码依赖的是JCL的接口，你就可以很方便的在各种日志工具做切换。</p><p>当然统一日志局面也是要有“相应能力”的，显然JCL在这方面做得不够好，开发人员发现了JCL还不够好，有些人甚至认为JCL造成的问题比解决的问题还多。</p><h3 id="英雄登场——Slf4j-amp-Logback"><a href="#英雄登场——Slf4j-amp-Logback" class="headerlink" title="英雄登场——Slf4j&amp;Logback"></a>英雄登场——Slf4j&amp;Logback</h3><p>这里说的是“英雄”是指<strong>Ceki Gülcü</strong>（同时也是Log4j的作者），他觉得JCL不够好，所以开发出了一套更为优秀的日志框架<strong>Slf4j（Simple Logging Facade for Java）</strong>，同时也提供一个比Log4j更为优秀的默认实现<strong>Logback</strong>。为了适配现有一些日志工具（Log4j，JUL），<strong>Ceki Gülcü</strong>也为一系列日志工具提供了桥接包，如slf4j-log4j12（Slf4j-Log4j桥接包）。当然只有日志工具的桥接包是不够的，如果当前应用使用了JCL日志框架，现在要使用Slf4j作为统一日志框架输出日志怎么办？桥接，当前桥接包不够那就再加一个，于是就有了slf4j-over-jcl（slf4j替换JCL）。</p><p>于是，现有的日志工具和日志框架的使用逻辑如下：</p><p><img src="Java%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0_1.png"></p><p>图片来源：<a href="https://segmentfault.com/img/bVbAMVm">https://segmentfault.com/img/bVbAMVm</a></p><p><strong>注：</strong>使用桥接包时一定要注意避免环形依赖问题（会造成StackOverflow）。日志框架和日志工具或日志框架之间的两个桥接包一定不能同时存在。slf4j-xxx包作用是接口使用slf4j这一套，底层日志实现使用具体的xxx； xxx-over-slf4j包作用是对于xxx调用会转调slf4j接口。</p><h3 id="王者归来——Log4j-2（Log4j-api-amp-Log4j-core）"><a href="#王者归来——Log4j-2（Log4j-api-amp-Log4j-core）" class="headerlink" title="王者归来——Log4j 2（Log4j-api&amp;Log4j-core）"></a>王者归来——Log4j 2（Log4j-api&amp;Log4j-core）</h3><p>你以为这样子就结束了？为了维护在 Java 日志江湖的地位，Apache重写了Log4j 1.x，成立了新的项目Log4j 2, 且Log4j 2具有Logback的所有特性。<strong>Log4j-api</strong>作为全新的日志框架，<strong>Log4j-core</strong>则作为它的默认实现，除了具有Logback所有特性之外，还新增了很多其他新特性，具体在<a href="http://logging.apache.org/log4j/2.x/index.html">Log4j 2官网</a>。当然，随着全新的日志框架和日志工具的出现，这次同样也带来了一大堆桥接包。具体如下：</p><p><img src="Java%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0_2.png"></p><p>图片来源：<a href="https://segmentfault.com/img/bVbAMVm">https://segmentfault.com/img/bVbAMVm</a></p><p>以上就是Java日志体系各阶段的发展历史了，到今天已然变成了“三分天下”的混乱局面。只怪当初的Sun公司不够争气，要是当初能像JDBC一样提出一套Java日志规范（接口）就没后面这么多事了。所以，<strong>面向接口编程是非常重要的</strong>！！！</p><h2 id="日志框架和工具的选择"><a href="#日志框架和工具的选择" class="headerlink" title="日志框架和工具的选择"></a>日志框架和工具的选择</h2><p>根据我写这篇文章在网上搜索文章的经历，目前<strong>Slf4j+Logback</strong>组合是当前最热门，刚好我工作中使用的也是这套。</p><h2 id="如何排除项目中依赖的第三方包的日志依赖"><a href="#如何排除项目中依赖的第三方包的日志依赖" class="headerlink" title="如何排除项目中依赖的第三方包的日志依赖"></a>如何排除项目中依赖的第三方包的日志依赖</h2><p>在项目开发过程中，项目会根据需要引入一些第三方库，例如常用的 Spring，而 Spring 本身的日志实现使用了commons-logging（JCL），如果想使用 Slf4j+Logback 组合，这时候需要在项目中将 commons-logging排除掉，通常会用到以下 3 种方案，各有利弊，可以根据项目的实际情况选择最适合自己项目的解决方案。</p><ul><li><p>采用 maven 的 exclusion 方案这种方案优点是 exclusion 是 maven 原生提供的，不足之处是如果有多个组件都依赖了 commons-logging，则需要在很多处增加 exclusion，比较繁琐。（我一般使用这种方法）</p></li><li><p>在 maven 声明 commons-logging 的 scope 为 provided，这种方案虽然简洁，但也有缺点，在调试代码时有可能导致 IDE 将 commons-logging 放置在 classpath 下，从而导致程序运行时出现异常。</p></li><li><p>在 maven 私服中增加类似于 99.0-does-not-exist 这种虚拟的版本号。这种方案好处在于声明方式比较简单，用 IDE 调试代码时也不会出现问题，不足之处是 99.0-does-not-exist 这种版本是 maven 中央仓库中可能不存在，需要发布到自己的 maven 私服中。</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>99.0-does-not-exist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位移在枚举中的应用</title>
      <link href="/wei-yi-zai-mei-ju-zhong-de-ying-yong/"/>
      <url>/wei-yi-zai-mei-ju-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="位移在枚举中的应用"><a href="#位移在枚举中的应用" class="headerlink" title="位移在枚举中的应用"></a>位移在枚举中的应用</h1><p>最近在公司代码中发现一个枚举类中使用了位移来表示枚举值，不是很能理解为何这样设置，遂去问了度娘和老同事。大概意思就是存在多个枚举组合使用的情况下使用位移能很方便的分辨出是哪些枚举。</p><pre class=" language-Java"><code class="language-Java">public enum BusinessType &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);&#125;</code></pre><p>如上是一个产品线枚举，如果想判断某个产品是否同时属于产品线A和产品线B，可以这样子来判断：</p><pre class=" language-Java"><code class="language-Java">    Integer type = BusinessType.A.getCode() + BusinessType.B.getCode();    if ((obj.getBusinessType() & type) == type) &#123;    &#125;</code></pre><h2 id="举一反三，在检验场景中的使用"><a href="#举一反三，在检验场景中的使用" class="headerlink" title="举一反三，在检验场景中的使用"></a>举一反三，在检验场景中的使用</h2><p>接上次的检验场景，表单对象中的用户可选的标签中有几个有冲突不能同时选择，在保存表单对象必须对这些情况进行检验。</p><h3 id="1-构建枚举类"><a href="#1-构建枚举类" class="headerlink" title="1.构建枚举类"></a>1.构建枚举类</h3><p>很幸运，公司代码中已经有用户选择标签的枚举类了，但是没有可供使用的位移枚举值，因此扩展一下，如下：</p><pre class=" language-Java"><code class="language-Java">public enum Label &#123;    A("AAA", 1 << 0),    B("BBB", 1 << 1),    C("CCC", 1 << 2);    D("DDD", 1 << 3);&#125;</code></pre><h3 id="2-设计冲突规则-amp-计算校验和"><a href="#2-设计冲突规则-amp-计算校验和" class="headerlink" title="2.设计冲突规则&amp;计算校验和"></a>2.设计冲突规则&amp;计算校验和</h3><p>比如，A和B不能同时选择校验规则，至少选择一个标签，当然也适用比较复杂的校验规则，如必须ABCD之间自由组合，这些规则可以按如下设计：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// AB不能同时选择</span>    Integer ABConflictRule <span class="token operator">=</span> Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 至少选择一个</span>    Integer leastOneCheckedRule <span class="token operator">=</span> ABConflictRule <span class="token operator">+</span> Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> complexCheckRule <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>                            Label<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>C<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Label<span class="token punctuation">.</span>D<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>冲突规则设计完毕之后，就需要计算所选择标签的校验和了，</p><pre class=" language-Java"><code class="language-Java">    int checkSum = 0;    for (Label label : query.getLabels()) &#123;        checkSum += Lable.descOf(label.getDesc).getCode();    &#125;</code></pre><h3 id="3-进行校验"><a href="#3-进行校验" class="headerlink" title="3.进行校验"></a>3.进行校验</h3><p>对校验和和冲突规则使用位移运算，然后根据位移运算之后的结果判断是否冲突，如：</p><pre class=" language-Java"><code class="language-Java">    if ((ABConflictRule & checkSum) == ABConflictRule) &#123;        System.out.println("AB冲突了");    &#125;    if ((leastOneCheckedRule & checkSum) == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 也可以这样    if (chcksum == 0) &#123;        System.out.println("没有选择标签");    &#125;    // 至少选择一个标签 && 不能选择一个标签 = ABCD之间自由组合    if ((leastOneCheckedRule & checkSum) == 0 && complexCheckRule.contains(checkSum)) &#123;        System.out.println("标签之间没有自由组合");    &#125;</code></pre><p>最后一个校验稍微有点复杂，需要进行一下换算。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位移运算在工作中很少使用到，以前只知道位移效率高，可以用来替代 乘法 和 除法。对位移运算的理解和应用也仅仅只限于熟悉运算规则并进行计算而已，很难想到上面这种通过位移来进行筛选。其实关于上面这些操作在离散数学中都有介绍，只能怪自己当初摸鱼了（囧）。。。</p><p>现在总结一下位移运算一些很有特点的操作：</p><ul><li>交集：A &amp; B</li><li>并集：A | B</li><li>差集： A &amp; (~B)</li></ul><p>最后，在网上发现一些关于位移运算技巧：<a href="https://www.zhihu.com/question/38206659">位运算有什么奇技淫巧？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式在字段验证场景中的使用</title>
      <link href="/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/"/>
      <url>/ze-ren-lian-mo-shi-zai-zi-duan-yan-zheng-chang-jing-zhong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式在字段验证场景中的使用"><a href="#责任链模式在字段验证场景中的使用" class="headerlink" title="责任链模式在字段验证场景中的使用"></a>责任链模式在字段验证场景中的使用</h1><p>最近在搬砖过程中有一个保存大表单的需求（搬砖CRUD常态），在保存这个大表单之前有一系列的检验（字段校验使用了JSR303），表单名不能和已有的重名、表单数量、同时还有一些字段是互斥不能同时选择的等等一些情况。</p><p>当时做这个的时候直接if else一把梭了，不过写到后面发现满屏的if else怎么看怎么别扭。</p><pre class=" language-Java"><code class="language-Java">public boolean validate(Query query) &#123;    if (表单名验证)&#123;    &#125; else if (表单数量验证) &#123;    &#125; else if (时间校验) &#123;    &#125;    ...&#125;</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote><p>顾名思义，责任链模式（Chain of Responsibility Pattern）<strong>为请求创建了一个接收者对象的链</strong>。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，<strong>通常每个接收者都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会<strong>把相同的请求传给下一个接收者</strong>，依此类推。 </p><p>​                                                                                                                                        来源：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p></blockquote><p>简而言之，责任链模式就是一个对象经过一系列链接成链条的处理对象从而进行一系列处理。</p><p>从上面的定义可以看出责任链模式非常适合用来对同一个对象进行一系列处理的场合，如SpringMVC的拦截器使用场景，对Request进行拦截处理。对表单对象进行检验的场景也非常适合使用责任链模式。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在校验场景中，待处理对象就是表单对象，一系列的进行处理的对象则是一系列的校验器。因此首先需要一个校验器的接口，如下：</p><pre class=" language-Java"><code class="language-Java">public interface Validator &#123;    ValidateResult validate(ReportQuery reportQuery);&#125;</code></pre><p>对表单进行校验的校验器通过实现Validator接口即可：</p><pre class=" language-Java"><code class="language-Java">// 表单名验证public class ReportNameValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单名校验逻辑    &#125;&#125;// 表单数量验证public class ReportSizeValidator implements Validator &#123;    @Override    public ValidateResult validate(ReportQuery reportQuery) &#123;        // 表单数量校验逻辑    &#125;&#125;</code></pre><p>链条上的进行处理的对象已经有了，现在需要一个可以把这些处理对象链接起来的并且可以按照链条顺序一一执行校验的对象：</p><pre class=" language-Java"><code class="language-Java">public class ReportValidator &#123;    // 检验器集合    private List<Validator> validators = new ArrayList<>();    // 添加校验器并链接成链条    public ReportValidator addValidator(Validator validator) &#123;        validators.add(validator);        return this;    &#125;    // 按照链条顺序执行校验    public ValidateResult validate(ReportQuery reportQuery) &#123;        ValidateResult validateResult = null;        for (Validator validator : validators) &#123;            validateResult = validator.validate(reportQuery);            if (!validateResult.isSuccess()) &#123;                return validateResult;            &#125;        &#125;        return validateResult;    &#125;&#125;</code></pre><p>然后，使用起来是这样子的：</p><pre class=" language-Java"><code class="language-Java">    @PostMapping("/urlpath")    public JsonCommonResponse fun(@RequestBody ReportQuery reportQuery) &#123;        // 校验        ReportValidator reportValidator = new ReportValidator().addValidator(new ReportNameValidator())                .addValidator(new ReportSizeValidator());        ValidateResult validateResult = reportValidator.validate(reportQuery);        if (!validateResult.isSuccess()) &#123;            return JsonCommonResponse.failRes(validateResult.getResultCode());        &#125;        // 业务逻辑    &#125;</code></pre><p>这样子使用起来十分方便，而且可读性也很好，扩展也十分方便，如果有新的校验逻辑，新建一个检验器类，添加到链条中即可。</p><p><strong>注：</strong>一些校验器的检验逻辑可能会依赖它前面的校验结果，可能会导致NPE（检验器的添加顺序也请务必仔细考虑）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式非常适合用于<strong>对一个对象进行一系列的处理</strong>，如过滤（过滤器），拦截（拦截器），检验（检验器）。</p><p>表单校验使用责任链模式和JSR303配合校验十分方便，而且可读性可维护性扩展性都挺不错。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖日志 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ning0h2o的第一篇Blog</title>
      <link href="/ning0h2o-de-di-yi-pian-blog/"/>
      <url>/ning0h2o-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Ning0h2o的第一篇Blog"><a href="#Ning0h2o的第一篇Blog" class="headerlink" title="Ning0h2o的第一篇Blog"></a>Ning0h2o的第一篇Blog</h1><p>Hi，这里是Ning0h2o的blog，一枚刚进入职场的Java搬砖工程师~~</p><h2 id="一段简短的自我介绍"><a href="#一段简短的自我介绍" class="headerlink" title="一段简短的自我介绍"></a>一段简短的自我介绍</h2><p>ning0h2o（这个昵称可以转化成我的姓名哦，化学表达式+谐音这样子？），2020届大学毕业生，现在在狗东搬砖，唯一的兴趣就是打游戏打游戏打游戏了</p><h2 id="这个博客有什么内容？"><a href="#这个博客有什么内容？" class="headerlink" title="这个博客有什么内容？"></a>这个博客有什么内容？</h2><p>Java开发方面的技术记录文，类似个人学习笔记和开发笔记，大多会是一些知识点的罗列和简单说明，不会太深层次的去研讨技术（大佬请绕道）。</p><h2 id="写博客的理由"><a href="#写博客的理由" class="headerlink" title="写博客的理由"></a>写博客的理由</h2><ol><li>我记了很多笔记，有道云笔记现在大概有300来篇笔记了吧，但是都是一些零零散散的知识点，分类也乱七八糟的。而且在我记完笔记之后很少去看，到现在有些已经遗忘的差不多了。通过写博客的方式review和重新编排一下，同时也是把这些知识点构建成知识体系的有效途径</li><li>到现在已经入职一个多月了，对自己所在岗位也有一定的了解，我会在接下来一段相对长的时间从事搬砖的活（谁叫自己菜呢）。不过还好，开发用的那套技术栈和我掌握的重合性很高，很多知识点也是在我的笔记里有所记录。因此，写博客复习也有助于搬砖（误）</li><li>俗话说的好，“靠山山倒”。在开发这条路上总不能就靠我那百来多篇笔记了吧？那样子的话一辈子都是搬砖工了（笑）。我会去学习一些新技术，并且通过写博客的方式记录知识点和我的一些理解</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>能看到这儿的话，说明你是真的闲（笑）。从我上面写的内容你也大概看的出我文笔菜的一批，说来也惭愧，我高考语文差点不及格（苦笑）。在以后的博客写作中我会尽量保证语句通顺，在技术点说明这方面也会尽量保持正确性，个人理（忽）解（悠）处也会给出相应的标记（哈哈，不要被我忽悠了）</p><p>最后，十分感谢你能来到我的博客。如果你有什么建议或者想法对我说，可以在下方评论区留言，也可以加我企鹅号~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
